/**
 * gaussian_blur.c
 *
 * 'Gaussian Blur' alogrithm base on OpenCV.
 *
 * SEE ALSO
 *     http://www.swageroo.com/wordpress/how-to-program-a-gaussian-blur-without-using-3rd-party-libraries/
 */
#include <math.h>
#include <stdio.h>

#include "gaussian_blur.h"

#define GAUSSKERN 3.5

#ifndef max
#define max(a, b) ((a)>(b)?(a):(b))
#endif

static CvMat *
create_gaussian_kernel_2D(float sigma, int dim)
{
    float sigma_2, m, v, sum;
    int radius, i, j;
    CvMat *mat;

    mat = cvCreateMat(dim, dim, CV_32FC1);
#define MAT(ROW,COL) ((float *)(mat->data.ptr + mat->step * (ROW)))[(COL)]
    sigma_2 = 2 * sigma * sigma;
    radius = dim / 2;
    m = 1.0 / (M_PI * sigma_2);
    for (i = 0; i <= radius; ++i) {
        for (j = 0; j <= radius; ++j) {
            v = m * exp(-(1.0*i*i+1.0*j*j) / sigma_2);
            MAT(radius+i, radius+j) = v;
            MAT(radius-i, radius+j) = v;
            MAT(radius+i, radius-j) = v;
            MAT(radius-i, radius-j) = v;
        }
    }
    /**
     * normalize the matrix.
     */
    for (i = 0; i < dim; ++i) {
        for (j = 0; j < dim; ++j) {
            sum += MAT(i, j);
        }
    }
    v = 1.0 / sum;
    for (i = 0; i < dim; ++i) {
        for (j = 0; j < dim; ++j) {
            MAT(i, j) *= v;
        }
    }
    return mat;
#undef MAT
}

static void
convolve_2D(CvMat *kernel, int dim, IplImage *src, IplImage *dst)
{
#define DATA_PTR(IMG, ROW, COL) ((IMG)->imageData + (IMG)->widthStep * (ROW) + (COL) * (IMG)->nChannels)

#define KERNEL(ROW,COL) ((float *)(kernel->data.ptr + kernel->step * (ROW)))[(COL)]
    int x, y, i, j, k, row, col, radius;
    unsigned char *data;
    float pixel[8];

    radius = dim / 2;
    for (y = 0; y < src->height; ++y) {
        for (x = 0; x < src->width; ++x) {
            for (k = 0; k < src->nChannels; ++k) {
                pixel[k] = 0.0f;
            }
            for (j = 0; j < dim; ++j) {
                for (i = 0; i < dim; ++i) {
                    col = x + (i - radius);
                    row = y + (j - radius);
                    if (col < 0 || col >= src->width) {
                        col = x;
                    }
                    if (row < 0 || row >= src->height) {
                        row = y;
                    }
                    data = (unsigned char *)DATA_PTR(src, row, col);
                    for (k = 0; k < src->nChannels; ++k) {
                        pixel[k] += KERNEL(j, i) * data[k];
                    }
                }
            }
            data = (unsigned char *)DATA_PTR(dst, y, x);
            for (k = 0; k < src->nChannels; ++k) {
                data[k] = pixel[k];
            }
        }
    }
    return ;
#undef DATA_PTR
#undef KERNEL
}

int
gaussian_blur_2D(IplImage *src, IplImage *dst, float sigma)
{
    int dim;
    IplImage *tmp;
    CvMat *kernel;

    dim = (int)max(3.0f, 2.0 * GAUSSKERN * sigma + 1.0f);
    if (dim % 2 == 0) {
        ++dim;
    }
    tmp = cvCreateImage(cvGetSize(src), src->depth, src->nChannels);
    cvCopy(src, tmp, 0);
    kernel = create_gaussian_kernel_2D(sigma, dim);
    convolve_2D(kernel, dim, tmp, dst);
    cvReleaseMat(&kernel);
    cvReleaseImage(&tmp);
    return dim;
}

/******************************************************************************/

/**
 * function to create a vector of gaussian kernel.
 *
 * @param sigma blurring factor.
 * @param dim diameter of gaussian kernel.
 *
 * @return point to the first element of a array which represents the vector
 *         of gaussian kernel.
 */
static float *
create_gaussian_kernel_1D(float sigma, int dim)
{
    int i;
    float *kernel, sigma_2, m, v;
    int radius;
    
    kernel = (float *)malloc(dim * sizeof(float));
    sigma_2 = 2.0 * sigma * sigma;
    radius = dim / 2;
    m = 1.0 / sqrt(M_PI * sigma_2);
    for (i = 0; i <= radius; ++i) {
        v = m * exp(-(1.0*i*i)/sigma_2);
        kernel[radius-i] = v;
        kernel[radius+i] = v;
    }
    /**
     * we don't need to normalize the kernel vector because the diameter are
     * generated by GAUSSKERN and sigma. The sum of vector's column is almost
     * equal to 1.
     */
#if 0
    sum = 0.0f;
    for (i = 0; i < dim; ++i) {
        sum += kernel[i];
    }
    v = 1.0f / sum;
    for (i = 0; i < dim; ++i) {
        kernel[i] *= v;
    }
#endif
    return kernel;
}

/**
 * function to convolve along with horizental direction.
 */
static void
convolve_width_1D(float *kernel, int dim, IplImage *src, IplImage *dst)
{
#define DATA_PTR(IMG, ROW, COL) ((IMG)->imageData + (IMG)->widthStep * (ROW) + (COL) * (IMG)->nChannels)
    int x, y, i, k, col, radius;
    float pixel[8];
    unsigned char *data;

    radius = dim / 2;
    for (y = 0; y < src->height; ++y) {
        for (x = 0; x < src->width; ++x) {
            for (k = 0; k < src->nChannels; ++k) {
                pixel[k] = 0.0f;
            }
            for (i = 0; i < dim; ++i) {
                col = x + (i - radius);
                if (col < 0 || col >= src->width) {
                    col = x;
                }
                data = (unsigned char *)DATA_PTR(src, y, col);
                for (k = 0; k < src->nChannels; ++k) {
                    pixel[k] += kernel[i] * data[k];
                }
            }
            data = (unsigned char *)DATA_PTR(dst, y, x);
            for (k = 0; k < src->nChannels; ++k) {
                data[k] = pixel[k];
            }
        }
    }
    return ;
#undef DATA_PTR
}

/**
 * function to convolve along with vertical direction.
 */
static void
convolve_height_1D(float *kernel, int dim, IplImage *src, IplImage *dst)
{
#define DATA_PTR(IMG, ROW, COL) ((IMG)->imageData + (IMG)->widthStep * (ROW) + (COL) * (IMG)->nChannels)
    int x, y, j, k, row, radius;
    float pixel[8];
    unsigned char *data;

    radius = dim / 2;
    for (y = 0; y < src->height; ++y) {
        for (x = 0; x < src->width; ++x) {
            for (k = 0; k < src->nChannels; ++k) {
                pixel[k] = 0.0f;
            }
            for (j = 0; j < dim; ++j) {
                row = y + (j - radius);
                if (row < 0 || row >= src->height) {
                    row = y;
                }
                data = (unsigned char *)DATA_PTR(src, row, x);
                for (k = 0; k < src->nChannels; ++k) {
                    pixel[k] += kernel[j] * data[k];
                }
            }
            data = (unsigned char *)DATA_PTR(dst, y, x);
            for (k = 0; k < src->nChannels; ++k) {
                data[k] = pixel[k];
            }
        }
    }
    return ;
#undef DATA_PTR
}

/**
 * function to blur a image using 'Gaussian Blur'.This function is faster than
 * gaussian_blur_2D benefit from the special property of 'Gaussian Blur' called
 * separability.
 *
 * @param src point of a image to be blurred.
 * @param dst point of a image to store the blurred image.
 * @param sigma blurring factor, control the gaussian kernel's size, the larger
 *              this number is, the smoother the image becomes.
 *
 * @return diameter of gaussian kernel.
 *
 * NOTE
 *     src and dst CAN point to a same image, because function create a 
 * temporary image to store the source image during the process.
 */
int
gaussian_blur_1D(IplImage *src, IplImage *dst, float sigma)
{
    float *kernel;
    IplImage *tmp;
    int dim; 

    dim = (int)max(3.0f, 2.0 * GAUSSKERN * sigma + 1.0f);
    if (dim % 2 == 0) {
        ++dim;
    }
    tmp = cvCreateImage(cvGetSize(src), src->depth, src->nChannels);
    kernel = create_gaussian_kernel_1D(sigma, dim);

    convolve_width_1D(kernel, dim, src, tmp);
    convolve_height_1D(kernel, dim, tmp, dst);
    cvReleaseImage(&tmp);
    free(kernel);
    return dim;
}
